import{parseEndpoint}from"./chunk-YWICFM2F.js";import uuid from"tiny-uid";import{serializeError}from"serialize-error";var createEndpointRuntime=(e,t,s)=>{const n=uuid(),r=new Map,a=new Map,o=i=>{if(i.destination.context===e&&!i.destination.frameId&&!i.destination.tabId){null==s||s(i);const{transactionId:t,messageID:n,messageType:m}=i,d=()=>{const e=r.get(t);if(e){const{err:s,data:n}=i;if(s){const t=s,n=self[t.name],r=new("function"==typeof n?n:Error)(t.message);for(const e in t)r[e]=t[e];e.reject(r)}else e.resolve(n);r.delete(t)}},c=async()=>{let t,s,r=!1;try{const s=a.get(n);if("function"!=typeof s)throw r=!0,new Error(`[webext-bridge] No handler registered in '${e}' to accept messages with id '${n}'`);t=await s({sender:i.origin,id:n,data:i.data,timestamp:i.timestamp})}catch(e){s=e}finally{if(s&&(i.err=serializeError(s)),o({...i,messageType:"reply",data:t,origin:{context:e,tabId:null},destination:i.origin,hops:[]}),s&&!r)throw t}};switch(m){case"reply":return d();case"message":return c()}}return i.hops.push(`${e}::${n}`),t(i)};return{handleMessage:o,endTransaction:e=>{const t=r.get(e);null==t||t.reject("Transaction was ended before it could complete"),r.delete(e)},sendMessage:(t,s,n="background")=>{const a="string"==typeof n?parseEndpoint(n):n;if(!a.context)throw new TypeError("Bridge#sendMessage -> Destination must be any one of known destinations");return new Promise(((n,i)=>{const m={messageID:t,data:s,destination:a,messageType:"message",transactionId:uuid(),origin:{context:e,tabId:null},hops:[],timestamp:Date.now()};r.set(m.transactionId,{resolve:n,reject:i});try{o(m)}catch(e){r.delete(m.transactionId),i(e)}}))},onMessage:(e,t)=>(a.set(e,t),()=>a.delete(e))}};import{createNanoEvents}from"nanoevents";import uuid2 from"tiny-uid";var _Stream=class{constructor(e,t){this.endpointRuntime=e,this.streamInfo=t,this.emitter=createNanoEvents(),this.isClosed=!1,this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},_Stream.initDone||(e.onMessage("__crx_bridge_stream_transfer__",(e=>{const{streamId:t,streamTransfer:s,action:n}=e.data,r=_Stream.openStreams.get(t);r&&!r.isClosed&&("transfer"===n&&r.emitter.emit("message",s),"close"===n&&(_Stream.openStreams.delete(t),r.handleStreamClose()))})),_Stream.initDone=!0),_Stream.openStreams.set(this.streamInfo.streamId,this)}get info(){return this.streamInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:e,action:"transfer"},this.streamInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:null,action:"close"},this.streamInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,t){const s=this.emitter.on(e,t);return Object.assign(s,{dispose:s,close:s})}},Stream=_Stream;Stream.initDone=!1,Stream.openStreams=new Map;var createStreamWirings=e=>{const t=new Map,s=new Map,n=createNanoEvents();return e.onMessage("__crx_bridge_stream_open__",(t=>new Promise((r=>{const{sender:a,data:o}=t,{channel:i}=o;let m=!1,d=()=>{};const c=()=>{const t=s.get(i);"function"==typeof t?(t(new Stream(e,{...o,endpoint:a})),m&&d(),r(!0)):m||(m=!0,d=n.on("did-change-stream-callbacks",c))};c()})))),{openStream:async function(s,n){if(t.has(s))throw new Error("webext-bridge: A Stream is already open at this channel");const r="string"==typeof n?parseEndpoint(n):n,a={streamId:uuid2(),channel:s,endpoint:r},o=new Stream(e,a);return o.onClose((()=>t.delete(s))),await e.sendMessage("__crx_bridge_stream_open__",a,r),t.set(s,o),o},onOpenStreamChannel:function(e,t){if(s.has(e))throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");s.set(e,t),n.emit("did-change-stream-callbacks")}}};export{createEndpointRuntime,createStreamWirings};